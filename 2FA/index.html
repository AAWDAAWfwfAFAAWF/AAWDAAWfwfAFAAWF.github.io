<!DOCTYPE html>
<html lang="en">d
<head>
  <link rel="icon" href="https://raw.githubusercontent.com/AAWDAAWfwfAFAAWF/AAWDAAWfwfAFAAWF.github.io/refs/heads/main/Icons/Yeserrr.png" type="image/png" />
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>2FA Shit</title>
  <style>
    /* Reset & Base */
    * {
      box-sizing: border-box;
    }
    body, html {
      margin: 0; padding: 0; height: 100%;
      background: #000;
      color: #fff;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      overflow-x: hidden;
      user-select: none;
      position: relative;
    }
    #particles-js {
      position: fixed;
      top: 0; left: 0; width: 100%; height: 100%;
      z-index: 0;
      pointer-events: none;
      background: #000;
    }
    main {
      position: relative;
      z-index: 1;
      max-width: 720px;
      margin: 2rem auto 3rem auto;
      background: #111;
      border-radius: 8px;
      box-shadow: 0 0 15px 3px #222;
      padding: 1.5rem 2rem 2rem 2rem;
    }
    form {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 1.5rem;
    }
    input[type="text"] {
      flex: 1 1 60%;
      padding: 0.6rem 0.8rem;
      font-size: 1rem;
      border: 1px solid #555;
      border-radius: 4px;
      background: #000;
      color: #fff;
      font-family: monospace;
      letter-spacing: 1.5px;
      user-select: text;
    }
    input[type="text"]:focus {
      outline: 2px solid #fff;
      border-color: #fff;
    }
    button {
      flex: 1 1 30%;
      background-color: #fff;
      border: none;
      color: #000;
      font-weight: 700;
      cursor: pointer;
      border-radius: 4px;
      font-size: 1rem;
      padding: 0.6rem;
      user-select: none;
      transition: background-color 0.15s ease, color 0.15s ease;
    }
    button:hover, button:focus {
      background-color: #ddd;
      outline: none;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      table-layout: fixed;
    }
    th, td {
      padding: 0.6rem 0.8rem;
      border-bottom: 1px solid #333;
      text-align: left;
      vertical-align: middle;
      font-size: 1rem;
    }
    th {
      border-bottom: 2px solid #444;
      font-weight: 700;
      user-select: none;
    }
    td.actions {
      text-align: right;
      width: 90px;
    }
    button.delete-btn {
      background-color: #800000;
      color: #fff;
      padding: 0.25rem 0.5rem;
      font-size: 0.9rem;
      border-radius: 4px;
      user-select: none;
    }
    button.delete-btn:hover, button.delete-btn:focus {
      background-color: #aa0000;
      outline: none;
    }
    .totp-code {
      font-family: monospace;
      font-weight: 700;
      font-size: 1.4rem;
      letter-spacing: 0.3rem;
      text-align: center;
      cursor: pointer;
      user-select: text;
      position: relative;
      padding: 0.1rem 0.3rem;
      border-radius: 3px;
      color: #fff;
      transition: background-color 0.3s ease;
    }
    .totp-code:hover, .totp-code:focus {
      background-color: #222;
      outline: none;
    }
    .progress-container {
      width: 100%;
      height: 6px;
      background-color: #222;
      border-radius: 3px;
      margin-top: 5px;
      user-select: none;
    }
    .progress-bar {
      height: 6px;
      background-color: #fff;
      border-radius: 3px;
      transition: width 0.1s linear;
      width: 100%;
    }
    .secret-cell {
      font-family: monospace;
      letter-spacing: 2px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 180px;
      user-select: text;
      color: #aaa;
    }
    .secret-cell.hidden {
      filter: blur(6px);
      user-select: none;
      cursor: default;
    }
    button.show-secret-btn {
      background: none;
      border: 1px solid #555;
      color: #aaa;
      padding: 0.25rem 0.5rem;
      font-size: 0.85rem;
      border-radius: 4px;
      cursor: pointer;
      user-select: none;
      transition: color 0.3s ease, border-color 0.3s ease;
      margin-left: 8px;
    }
    button.show-secret-btn:hover, button.show-secret-btn:focus {
      color: #fff;
      border-color: #fff;
      outline: none;
    }
    #download-btn {
      margin-top: 1.5rem;
      background-color: #fff;
      color: #000;
      font-weight: 700;
      width: 100%;
      padding: 0.75rem;
      font-size: 1.1rem;
      border-radius: 4px;
      user-select: none;
      cursor: pointer;
      border: none;
      transition: background-color 0.2s ease, color 0.2s ease;
    }
    #download-btn:hover, #download-btn:focus {
      background-color: #ddd;
      outline: none;
    }
    /* Tooltip */
    .tooltip {
      position: absolute;
      top: -1.8rem;
      left: 50%;
      transform: translateX(-50%);
      background: #fff;
      color: #000;
      font-size: 0.75rem;
      padding: 0.15rem 0.5rem;
      border-radius: 3px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s ease;
      user-select: none;
      white-space: nowrap;
      z-index: 10;
    }
    .tooltip.visible {
      opacity: 1;
    }
    /* Bottom popup message */
    #popup-message {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background-color: rgba(255,255,255,0.9);
      color: #000;
      padding: 0.5rem 1rem;
      border-radius: 20px;
      font-weight: 700;
      font-size: 1rem;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
      z-index: 10000;
      user-select: none;
      box-shadow: 0 0 8px rgba(0,0,0,0.3);
    }
    #popup-message.visible {
      opacity: 1;
      pointer-events: auto;
    }
    @media (max-width: 480px) {
      form {
        flex-direction: column;
      }
      input[type="text"], button {
        flex: 1 1 100%;
      }
      .secret-cell {
        max-width: 100%;
      }
    }
  </style>
</head>
<body>
  <div id="particles-js"></div>
  <main>
    <form id="addForm" autocomplete="off" onsubmit="return false;">
      <input type="text" id="labelInput" placeholder="Account label (e.g. GitHub)" required aria-label="Account label" />
      <input type="text" id="secretInput" placeholder="2FA Secret (Base32)" required aria-label="2FA secret" />
      <button id="addBtn" type="submit" aria-label="Add 2FA secret">Add 2FA</button>
    </form>

    <table id="secretsTable" aria-label="2FA secrets list">
      <thead>
        <tr>
          <th style="width: 30%;">Account</th>
          <th style="width: 18%;">Current Code</th>
          <th style="width: 30%;">Secret</th>
          <th class="actions" style="width: 90px;">Actions</th>
        </tr>
      </thead>
      <tbody>
        <!-- Dynamic rows -->
      </tbody>
    </table>

    <button id="download-btn" aria-label="Download 2FA secrets as JSON">Download Secrets as TXT</button>
  </main>

  <div id="popup-message" role="alert" aria-live="assertive" aria-atomic="true"></div>

  <!-- Load particles.js for snow effect -->
  <script src="https://cdn.jsdelivr.net/npm/particles.js@2.0.0/particles.min.js"></script>

  <script>
    // Initialize particles.js with white snow effect
    particlesJS('particles-js', {
      "particles": {
        "number": {
          "value": 120,
          "density": {
            "enable": true,
            "value_area": 800
          }
        },
        "color": { "value": "#ffffff" },
        "shape": { "type": "circle" },
        "opacity": {
          "value": 0.8,
          "random": true,
          "anim": { "enable": false }
        },
        "size": {
          "value": 3,
          "random": true,
          "anim": { "enable": false }
        },
        "move": {
          "enable": true,
          "speed": 2,
          "direction": "bottom",
          "random": true,
          "straight": false,
          "out_mode": "out",
          "bounce": false
        }
      },
      "interactivity": {
        "detect_on": "canvas",
        "events": {
          "onhover": { "enable": false },
          "onclick": { "enable": false },
          "resize": true
        }
      },
      "retina_detect": true
    });

    // Base32 decode to hex
    function base32tohex(base32) {
      const base32chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
      let bits = "";
      let hex = "";

      base32 = base32.toUpperCase().replace(/=+$/, '');

      for (let i = 0; i < base32.length; i++) {
        const val = base32chars.indexOf(base32.charAt(i));
        if (val === -1) return null;
        bits += val.toString(2).padStart(5, '0');
      }

      for (let i = 0; i + 4 <= bits.length; i += 4) {
        const chunk = bits.substr(i, 4);
        hex += parseInt(chunk, 2).toString(16);
      }

      return hex;
    }

    // Hex string to Uint8Array
    function hexToBytes(hex) {
      const bytes = [];
      for (let c = 0; c < hex.length; c += 2) {
        bytes.push(parseInt(hex.substr(c, 2), 16));
      }
      return new Uint8Array(bytes);
    }

    // Integer to 8-byte big-endian Uint8Array
    function intToBytes(num) {
      const bytes = new Uint8Array(8);
      for (let i = 7; i >= 0; i--) {
        bytes[i] = num & 0xff;
        num = num >> 8;
      }
      return bytes;
    }

    // HMAC-SHA1 using Web Crypto API
    async function hmacSha1(keyBytes, messageBytes) {
      const cryptoKey = await crypto.subtle.importKey(
        "raw",
        keyBytes,
        { name: "HMAC", hash: "SHA-1" },
        false,
        ["sign"]
      );
      const signature = await crypto.subtle.sign("HMAC", cryptoKey, messageBytes);
      return new Uint8Array(signature);
    }

    // Generate TOTP code
    async function generateTOTP(secret, timeStep = 30, digits = 6) {
      const keyHex = base32tohex(secret);
      if (!keyHex) return null;
      const keyBytes = hexToBytes(keyHex);

      const epoch = Math.floor(Date.now() / 1000);
      const counter = Math.floor(epoch / timeStep);

      const counterBytes = intToBytes(counter);

      const hmac = await hmacSha1(keyBytes, counterBytes);

      const offset = hmac[hmac.length - 1] & 0x0f;
      const binCode =
        ((hmac[offset] & 0x7f) << 24) |
        ((hmac[offset + 1] & 0xff) << 16) |
        ((hmac[offset + 2] & 0xff) << 8) |
        (hmac[offset + 3] & 0xff);

      const otp = binCode % (10 ** digits);
      return otp.toString().padStart(digits, '0');
    }

    // DOM references
    const labelInput = document.getElementById('labelInput');
    const secretInput = document.getElementById('secretInput');
    const addBtn = document.getElementById('addBtn');
    const secretsTableBody = document.querySelector('#secretsTable tbody');
    const downloadBtn = document.getElementById('download-btn');
    const popupMessage = document.getElementById('popup-message');

    const STORAGE_KEY = 'local2fa_secrets';

    function loadSecrets() {
      const saved = localStorage.getItem(STORAGE_KEY);
      if (saved) {
        try {
          return JSON.parse(saved);
        } catch {
          return [];
        }
      }
      return [];
    }

    function saveSecrets(secrets) {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(secrets));
    }

    // Show a bottom popup message for 1 second
    let popupTimeout = null;
    function showPopupMessage(text) {
      if (popupTimeout) {
        clearTimeout(popupTimeout);
      }
      popupMessage.textContent = text;
      popupMessage.classList.add('visible');
      popupTimeout = setTimeout(() => {
        popupMessage.classList.remove('visible');
      }, 1000);
    }

    // Render secrets table and start TOTP updates
    async function renderSecrets() {
      const secrets = loadSecrets();
      secretsTableBody.innerHTML = '';

      if (secrets.length === 0) {
        const tr = document.createElement('tr');
        const td = document.createElement('td');
        td.colSpan = 4;
        td.style.textAlign = 'center';
        td.textContent = 'No 2FA secrets saved yet.';
        tr.appendChild(td);
        secretsTableBody.appendChild(tr);
        return;
      }

      for (let i = 0; i < secrets.length; i++) {
        const { label, secret } = secrets[i];
        const tr = document.createElement('tr');

        // Label
        const labelTd = document.createElement('td');
        labelTd.textContent = label;
        labelTd.title = label;
        tr.appendChild(labelTd);

        // Current TOTP code cell with copy-on-click
        const codeTd = document.createElement('td');
        codeTd.classList.add('totp-code');
        codeTd.setAttribute('tabindex', '0');
        codeTd.setAttribute('role', 'button');
        codeTd.setAttribute('aria-label', `Current TOTP code for ${label}, click to copy`);
        codeTd.textContent = 'Loading...';
        tr.appendChild(codeTd);

        // Secret cell with show/hide button
        const secretTd = document.createElement('td');
        secretTd.style.display = 'flex';
        secretTd.style.alignItems = 'center';

        const secretSpan = document.createElement('span');
        secretSpan.className = 'secret-cell hidden';
        secretSpan.textContent = secret;
        secretSpan.title = '2FA Secret (click Show Secret to reveal)';
        secretTd.appendChild(secretSpan);

        const toggleBtn = document.createElement('button');
        toggleBtn.type = 'button';
        toggleBtn.className = 'show-secret-btn';
        toggleBtn.textContent = 'Show Secret';
        toggleBtn.setAttribute('aria-pressed', 'false');
        toggleBtn.addEventListener('click', () => {
          const isHidden = secretSpan.classList.contains('hidden');
          if (isHidden) {
            secretSpan.classList.remove('hidden');
            toggleBtn.textContent = 'Hide Secret';
            toggleBtn.setAttribute('aria-pressed', 'true');
          } else {
            secretSpan.classList.add('hidden');
            toggleBtn.textContent = 'Show Secret';
            toggleBtn.setAttribute('aria-pressed', 'false');
          }
        });
        secretTd.appendChild(toggleBtn);
        tr.appendChild(secretTd);

        // Actions (delete button)
        const actionsTd = document.createElement('td');
        actionsTd.classList.add('actions');
        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = 'Delete';
        deleteBtn.className = 'delete-btn';
        deleteBtn.setAttribute('aria-label', `Delete 2FA secret for ${label}`);
        deleteBtn.addEventListener('click', () => {
          if (confirm(`Delete 2FA secret for "${label}"?`)) {
            deleteSecret(i);
          }
        });
        actionsTd.appendChild(deleteBtn);
        tr.appendChild(actionsTd);

        // Add to table
        secretsTableBody.appendChild(tr);

        // Save code cell for updating
        secrets[i].codeCell = codeTd;

        // Add progress bar container inside code cell
        const progressContainer = document.createElement('div');
        progressContainer.className = 'progress-container';
        const progressBar = document.createElement('div');
        progressBar.className = 'progress-bar';
        progressContainer.appendChild(progressBar);
        codeTd.appendChild(progressContainer);
        secrets[i].progressBar = progressBar;
      }

      startTOTPUpdate(secrets);

      // Add copy event listeners after render
      secrets.forEach((entry) => {
        const { codeCell } = entry;
        if (!codeCell) return;

        async function copyText() {
          const text = codeCell.childNodes[0].textContent.trim();
          try {
            if (navigator.clipboard && navigator.clipboard.writeText) {
              await navigator.clipboard.writeText(text);
              showPopupMessage('Code copied!');
            } else {
              // Fallback using execCommand
              const textarea = document.createElement('textarea');
              textarea.value = text;
              document.body.appendChild(textarea);
              textarea.select();
              const success = document.execCommand('copy');
              document.body.removeChild(textarea);
              if (success) {
                showPopupMessage('Code copied!');
              } else {
                showPopupMessage('Failed to copy code');
              }
            }
          } catch {
            showPopupMessage('Failed to copy code');
          }
        }

        codeCell.addEventListener('click', copyText);
        codeCell.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            copyText();
          }
        });
      });
    }

    // Update TOTP codes every second, progress bars smoothly with requestAnimationFrame
    let totpInterval = null;
    let animationFrameId = null;

    function startTOTPUpdate(secrets) {
      if (totpInterval) clearInterval(totpInterval);
      if (animationFrameId) cancelAnimationFrame(animationFrameId);

      async function updateCodes() {
        const epoch = Math.floor(Date.now() / 1000);
        for (let i = 0; i < secrets.length; i++) {
          const { secret, codeCell } = secrets[i];
          if (!codeCell) continue;
          const code = await generateTOTP(secret);
          if (codeCell.childNodes.length > 0) {
            codeCell.childNodes[0].textContent = code || 'Invalid';
          }
        }
      }

      function updateProgress() {
        const epoch = Date.now() / 1000;
        const timeStep = 30;
        const elapsed = epoch % timeStep;
        const fraction = 1 - (elapsed / timeStep);

        for (let i = 0; i < secrets.length; i++) {
          const { progressBar } = secrets[i];
          if (!progressBar) continue;
          progressBar.style.width = (fraction * 100) + '%';
        }

        animationFrameId = requestAnimationFrame(updateProgress);
      }

      updateCodes();
      totpInterval = setInterval(updateCodes, 1000);
      updateProgress();
    }

    // Add new secret
    function addSecret(label, secret) {
      label = label.trim();
      secret = secret.trim().toUpperCase().replace(/[^A-Z2-7]/g, '');

      if (!label || !secret) {
        showPopupMessage('Enter valid label and Base32 secret');
        return;
      }
      if (secret.length < 16) {
        if (!confirm('The secret looks short and might be invalid. Add anyway?')) {
          return;
        }
      }

      const secrets = loadSecrets();
      if (secrets.some(s => s.label.toLowerCase() === label.toLowerCase())) {
        if (!confirm('An entry with this label already exists. Add anyway?')) {
          return;
        }
      }

      secrets.push({ label, secret });
      saveSecrets(secrets);
      renderSecrets();

      labelInput.value = '';
      secretInput.value = '';
      labelInput.focus();
    }

    // Delete secret by index
    function deleteSecret(index) {
      const secrets = loadSecrets();
      if (index < 0 || index >= secrets.length) return;
      secrets.splice(index, 1);
      saveSecrets(secrets);
      renderSecrets();
    }

    // Download secrets as TXT file with JSON-like formatting
    function downloadSecrets() {
      const secrets = loadSecrets();
      if (secrets.length === 0) {
        showPopupMessage('No secrets to download');
        return;
      }
      // Pretty print JSON string
      const textContent = JSON.stringify(secrets.map(({label, secret}) => ({label, secret})), null, 2);
      const blob = new Blob([textContent], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);

      const a = document.createElement('a');
      a.href = url;
      a.download = '2fa-secrets.txt';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);

      showPopupMessage('Secrets downloaded');
    }

    // Event listeners
    addBtn.addEventListener('click', () => {
      addSecret(labelInput.value, secretInput.value);
    });

    secretInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        addSecret(labelInput.value, secretInput.value);
      }
    });

    downloadBtn.addEventListener('click', downloadSecrets);

    // Initial render
    renderSecrets();
  </script>
</body>
</html>
